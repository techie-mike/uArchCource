# Homework 3: Q/A
#### 1. Объясните смысл и напишите формулы для следующих метрик производительности процессора IPC, CPI, Performance, Dynamic Power

* IPC (instructions per cycle) - среднее количество инструкций, исполняемых процессором за 1 такт

$$ IPC = \frac{N}{M},\\ где\ N - количество\ инструкций,\ M - количество\ тактов $$

* CPI (cycles per instruction) - среднее количество тактов, затрачиваемое процессором на исполнение одной инструкции

$$ CPI = \frac{1}{IPC} $$

* Performance - скорость исполнения программы, вычисляемая по формуле:

$$ Perfomance = \frac{1}{Time} = \frac{1}{N_{cycles} * CPI * T_{cycle}} = \frac{1}{N_{instr}} * IPC * f, $$

$$ Time = N_{instrs} * CPI * T_{cycle}$$

* Dynamic Power - затрачиваемая мощность на перезарядку паразитных емкостей при переключении транзистров в процессоре.

$$ DynPower = \frac{1}{2} \cdot C_{eff} \cdot V_{dd}^2 \cdot a \cdot f, а\ - \ частота\ переключения\ транзистора $$

#### 2. Что такое суперскалярный (superscalar) процессор?

Суперскалярный процессор - процессор, способный обрабатывать более одной инструкции за такт, используя дополнительные вычислительные ресурсы (например, АЛУ, векторные или VLIW инструкции)

#### 3. Какие типы зависимостей по данным существуют? Приведите примеры аппаратных оптимизаций, которые позволяют сократить связанные задержки или разрешить каждый тип зависимостей.

* False dependencies:

    * Write-After-Write
    * Write-After-Read

    Данные зависимости не являются настоящими зависимостями, так как поздней инструкции не нужны данные с предшествующей.  Чтобы уменить эти false dependencies при исполнении программы можно провести register renaming. Маппинг между архитектурными и физическими регистрами поддерживается с помощью Register Aliases Table (RAT). Альтернативным способом борьбы с False dependency является разбиение операций store на вычисление адреса (STA) и вычисление данных (STD).

* True dependency
    * Read-After-Write

    Store не может быть спекулятивно исполнен или переупорядочен. Но можно попробовать сделать store forwarding - пробросить результат выполнения store инструкции напрямую в load инструкцию, минуя кэши и память. Ограничениями такого является совпадение: адресов и размеров store load. Пересечения по адресам помогает понять Load and Store Buffer.

#### 4. С какой целью инструкцию Store разделяют на микро-операции STA (Store address calculation) и STD (Store data calculation) ?

Мы хотим уменьшить количество зависимостей между load и store . load и store имеют зависимость, если адреса пересекаются. Но чтобы выяснить наличие пересечения адресов, необходимо знать адреса. В стандартной реализации адрес store, не будет известен до тех пор пока не будут готовы данные для записи. Хочется определять адрес store раньше, чем будут готовы даные, чтобы избежать лишних зависимостей между load/store инсрукциями. Для этого store разделяется на инструкции вычисления адреса STA (Store address calculation) и вычисления данных STD (Store data calculation).

#### 5. Объясните назначение и функции следующих аппаратных структур: ROB, Scheduler Queue (Issue Queue, Reservation Station), RAT, PRF, Load Buffer, Store Buffer

* ROB (reorder buffer). Исполнени инструкций в `out-of-order` производится отличнм от поданном на исполнение программой порядке. При этом важно сохранять соответствие состояний, чтобы в случае возникновения, например, исключений, прерываний или чего-нибудь не было различий с `linear order`. Для поддержания спекулятивного и архитектурного состояния существует ROB. В нем инструкция записывается и хранится в обычном порядке, но покидает ROB и обновляет архитектурное состояние при условии что эта инструкция становится самой старой и уже исполнена.

* Scheduler Queue (Issue Queue, Reservation Station) - по мере OOO исполнения требуется обходить все инструкции из ROB:
  * При помещении каждой инструкции в ROB для поиска data input для аллокации физического регистра
  * На каждом такте с целью идентификации готовых инструкций для отправки их на исполнение.

  Эти факторы также накладывают ограничение на максимальную длину ROB. Для митигации данной проблемы используют Scheduler Queue - очередь еще не исполненных инструкций, которые иначе хранились бы в ROB.

* RAT (register alias table) - таблица соответствия физических и архитектурных регистров используемая в register renaming.

* PRF (physical register file) регистровый файл физических регистров процессора. Каждая ячейка ROB содержит данные о переименовании target регистра инструкции - указатель в PRF.

* Load Buffer, Store Buffer - буферы инструкций из только load и store соответственно, используемые для ускорения их исполнения с учётом зависимостей по данным.

#### 6. Пусть каждая 5ая инструкция в процессоре это Branch. Предсказатель переходов имеет точность 90%. Оцените, ROB какого максимального размера имеет смысл для такого процессора.

Хотим избежать ситуации missprediction бранчей, поскольку в этом случае происходит очистка ROB, что делает его неэффективным. Оценим вероятность $P_N$ того, что для ROB размером $N$ все инструкции будут выполнены. Если каждая пятая инструкция - это бранч, то $P_{br} = 0.2$, а $P_{predict} = 0.9$ по условию. Если всего инструкций в ROB $N$, то бранчей из них $N_{br} = N \cdot P_{br}$ Вероятность того, что все бранчи будут предсказаны правильно $P_N = P_{predict}^{N_{br}} = P_{predict}^{N \cdot P_{br}}$ Отсюда находим $N = \frac{\ln P_N}{P_{br} \cdot \ln P_{predict}}$ Если взять $P_N = 0.95$, то $N \approx 2.43$. Делать ROB настолько маленьким скорее всего даже не имеет смысла.

#### 7. Что такое Memory Disambiguation?

Это набор механизмов OOO процессоров, позволяющие устранить зависимости инструкций по памяти, тем самым улучшая ILP (Instruction Level Parallelism). К таким техникам относятся вышеупомянутые register renaming, store forwarding, Load Buffer, Store Buffer и тд.

#### 8. В чем заключается проблема со спекулятивным исполнением Store инструкций?

Проблема заключается в невозможности отмены выполненной инструкции store, из-за чего store не могут быть исполнены спекулятивно (в отличие от load). Также между ними нельзя менять порядок.

#### 9. Что такое Store forwarding и Load speculation в OOO процессоре?

* Store Forwarding

  Для тех инструкций load, которые ждут исполнения пересекающегося store - записи значения в кэш, необязательно поддерживать оригинальный линейный порядок. Поэтому возможно брать значение load сразу из исполнения соответствующей инструкции store, что приводит к ускорению.

* Load Speculation

  Техника спекуляций store-load зависимостей. Позволяет не ждать всех предшествующих store, но исполняться спекулятивно, проверяя правильность предсказаний после исполнения микро-операции STA.

#### 10. Что такое Simultaneous Multithreading?

Техника состоит в том, что при неизменном количестве физических ядер каждый из них разделяется на два логических.

Каждый из логических ядер поддерживает собственное архитектурное состояние (архитектурные регистры и instruction pointer).

Техника осуществляется за счёт разделения ресурсов единого пайплайна между логическими ядрами:
* Replicated - ресурсы для поддержания состояния логического ядра; собственное hardware под каждое логическое ядро
* Partitioned - разделение ресурсов без репликации (в Single Thread режиме могли бы быть объединены)
* Shared
